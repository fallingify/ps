//핵심 : 연속된 소수의 합의 경우의 수
//2 3 5 7 11 13 17 19 23 29 31

1. 인풋까지의 모든 소수를 구하면서 소수전용 배열에 담는다. 
    1-1. 만약 5일때 
2. 카운트 ++ 한다. 
    2-1. 2 -> x, 2 + 3 -> o
    2-2. count + 1
    2-3. 2 + 3 + 5 -> x 합의 값이 초과하면 다음 수로 넘어감

3. 
    3-1. 3 -> x
    3-2. 3 + 5 -> x 합의 값이 초과하면 다음수로 넘어감 
4. 자기자신이 시작수면 끝
    4-1. 5 -> o 



1. 소수판별하는법
for(int i=2; i <math.sqrt(num) + 1; i++) {

}

🟡 풀이 접근
소수 리스트 생성 (에라토스테네스의 체)

소수를 빠르게 구하기 위해 에라토스테네스의 체를 사용하여 N 이하의 모든 소수를 미리 구함.
투 포인터 (Two Pointer) 사용

소수 리스트의 연속 부분합을 찾기 위해 투 포인터 활용
left와 right 두 개의 포인터를 이용하여 부분합을 조절하며 N을 찾

🟡 시간 복잡도
에라토스테네스의 체 → O(N log log N)
투 포인터 탐색 → O(N)
총 시간 복잡도 → O(N log log N) + O(N) ≈ O(N)

public class Main(){

    static boolean prime[];
    static ArrayList<Integer> prime_numbers = new ArrayList<>(); //진짜


    public static void main(String[] args) {
        BufferReadder br = new BufferReadder(InputStream(System.in));
        int N = Integer.parseInt(br.readLine()); 6

        //소수 구하기 
        prime = new boolean<>(N + 1);
        prime[0] = prime[1] = true; 
        for(int i=2; i*i <= N; i++){
            if(!prime[i]) {
                for(int j=i*i; j<= N; j++){
                    prime[j] = true; 
                }
            }
        } 
        for(int i=1; i<=N; i++) {
            if(!prime[i]) {
                prime_numbers.add(i);
            }
        }

        int start = 0, end = 0, sum =0, count =0;  //투 포인터 start, end
        while(true) {  //start=0 end=0
            if(sum >= N) sum -= prime_numbers.get(start++)
            else if(end == prime_numbers.size()) { break; }
            else{ sum += prime_numbers.get(end++)}
            if(N == sum) ++count; 
        }
        System.out.println(count);
    
    } 
}


public class Main{
    static boolean isprimes[]; 
    static ArrayList<Integer> prime_number = new ArrayList<>();

    public static main(String[] args) {
        BufferReadder br = new BufferReadder(InputStreamReader(System.in));
        int N = Integer.parseInt(br.readLine());

        isprimes = new boolean[N + 1];
        isprimes[0] = isprimes[1] = true; 
        
        for(int i=2; i*i<=N; i++){
            if(!prime[i]){  
                for(int j=i*i; j<=N; j+=i){
                    prime[j] = true; 
                }
            }
        }

        for(int i=1; i<=N; i++) {
            if(!prime[i]) {
                prime_number.add(i); 
            }
        }

        int start = 0, end =0, count = 0, sum =0; 
        while(true) {
            if(sum >= N) { sum -= prime_number.get(start--)}
            else if(end == prime_number.size()) {break; }
            else{
                sum += prime_number.get(end++);
            }

            if(N == sum) {
                count++; 
            }
        }
        System.out.println(count);

        
    }
}